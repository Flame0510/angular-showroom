<div class="intro-section">
  <h2>üéØ Cos'√® NgRx?</h2>
  <p>
    NgRx √® una libreria per la gestione dello stato in Angular basata sul
    pattern Redux. Fornisce un modo prevedibile di gestire lo stato
    dell'applicazione attraverso un flusso unidirezionale di dati.
  </p>

  <div class="architecture-diagram">
    <div class="flow-step">
      <div class="flow-box component">Component</div>
      <div class="flow-arrow">dispatch</div>
      <div class="flow-box action">Action</div>
    </div>
    <div class="flow-step">
      <div class="flow-arrow">‚Üí</div>
      <div class="flow-box reducer">Reducer</div>
      <div class="flow-arrow">‚Üí</div>
      <div class="flow-box store">Store</div>
    </div>
    <div class="flow-step">
      <div class="flow-arrow">select</div>
      <div class="flow-box selector">Selector</div>
      <div class="flow-arrow">subscribe</div>
    </div>
  </div>

  <div class="store-patterns">
    <h3>üì¶ Scegli il Pattern da Esplorare</h3>
    <p class="patterns-intro">
      Clicca su uno dei pattern per vedere una guida completa step-by-step
      con esempi dettagliati e spiegazioni per principianti.
    </p>
    <div class="patterns-comparison">
      <div
        class="pattern recommended clickable"
        [class.selected]="selectedPattern() === 'centralized'"
        (click)="selectPattern('centralized')">
        <h4>‚úÖ Store Centralizzato (Consigliato)</h4>
        <p>
          <strong>Pattern Redux:</strong> Store globale unico con stato combinato.
          Questo √® l'approccio consigliato per la maggior parte delle applicazioni
          in quanto fornisce una migliore visibilit√† dello stato, debug pi√π semplice
          e un flusso di dati coerente.
        </p>
        <div class="pattern-pros">
          <strong>Vantaggi:</strong>
          <ul>
            <li>Unica fonte di verit√† (single source of truth)</li>
            <li>Debug pi√π semplice con DevTools</li>
            <li>Migliore composizione dello stato</li>
            <li>Condivisione dati tra funzionalit√†</li>
          </ul>
        </div>
        <div class="select-hint">
          üëÜ Clicca per vedere la guida completa
        </div>
      </div>
      <div
        class="pattern alternative clickable"
        [class.selected]="selectedPattern() === 'feature'"
        (click)="selectPattern('feature')">
        <h4>‚ö° Feature Stores (Alternativa)</h4>
        <p>
          <strong>Pattern Modulare:</strong> Store separati per ogni funzionalit√†.
          Utile per moduli lazy-loaded o funzionalit√† completamente indipendenti
          che non hanno mai bisogno di condividere lo stato.
        </p>
        <div class="pattern-pros">
          <strong>Casi d'uso:</strong>
          <ul>
            <li>Funzionalit√† lazy-loaded</li>
            <li>Moduli completamente isolati</li>
            <li>Architettura micro-frontend</li>
            <li>Sistemi basati su plugin</li>
          </ul>
        </div>
        <div class="select-hint">
          üëÜ Clicca per vedere la guida completa
        </div>
      </div>
    </div>
  </div>
</div>

<div class="concepts-grid">
  <div class="concept-card">
    <div class="concept-header">
      <span class="concept-icon">üè™</span>
      <h3>Store (Centralizzato)</h3>
    </div>
    <p class="concept-description">
      Il contenitore centrale che mantiene l'intero stato dell'applicazione.
      √à l'unica fonte di verit√† (single source of truth). In questo progetto,
      usiamo uno store centralizzato con reducer combinati (pattern Redux).
    </p>
    <app-code-block [code]="storeCode" language="typescript" />
    <div class="key-points">
      <h4>Caratteristiche:</h4>
      <ul>
        <li>‚úì Immutabile</li>
        <li>‚úì Prevedibile</li>
        <li>‚úì Centralizzato</li>
        <li>‚úì Serializzabile</li>
      </ul>
    </div>
  </div>

  <div class="concept-card">
    <div class="concept-header">
      <span class="concept-icon">‚ö°</span>
      <h3>Actions</h3>
    </div>
    <p class="concept-description">
      Eventi che descrivono qualcosa che √® successo nell'applicazione.
      Sono l'unico modo per inviare dati allo store.
    </p>
    <app-code-block [code]="actionsCode" language="typescript" />
    <div class="key-points">
      <h4>Best Practices:</h4>
      <ul>
        <li>‚úì Usa nomi descrittivi</li>
        <li>‚úì Includi la sorgente [Source]</li>
        <li>‚úì Passa dati via props</li>
        <li>‚úì Mantienile semplici</li>
      </ul>
    </div>
  </div>

  <div class="concept-card">
    <div class="concept-header">
      <span class="concept-icon">‚öôÔ∏è</span>
      <h3>Reducers</h3>
    </div>
    <p class="concept-description">
      Funzioni pure che prendono lo stato corrente e un'action, e ritornano
      un nuovo stato. Sono responsabili della gestione delle transizioni di stato.
    </p>
    <app-code-block [code]="reducerCode" language="typescript" />
    <div class="key-points">
      <h4>Regole:</h4>
      <ul>
        <li>‚úì Funzioni pure</li>
        <li>‚úì No side effects</li>
        <li>‚úì No mutazioni dirette</li>
        <li>‚úì Ritornano nuovo stato</li>
      </ul>
    </div>
  </div>

  <div class="concept-card">
    <div class="concept-header">
      <span class="concept-icon">üîç</span>
      <h3>Selectors</h3>
    </div>
    <p class="concept-description">
      Funzioni pure per selezionare e derivare dati dallo store.
      Sono memoizzati per performance ottimali.
    </p>
    <app-code-block [code]="selectorsCode" language="typescript" />
    <div class="key-points">
      <h4>Vantaggi:</h4>
      <ul>
        <li>‚úì Memoizzazione</li>
        <li>‚úì Riutilizzabili</li>
        <li>‚úì Composizione</li>
        <li>‚úì Testabili</li>
      </ul>
    </div>
  </div>

  <div class="concept-card">
    <div class="concept-header">
      <span class="concept-icon">üåä</span>
      <h3>Effects</h3>
    </div>
    <p class="concept-description">
      Gestiscono side effects come chiamate HTTP, routing, storage, ecc.
      Ascoltano le actions e possono emettere nuove actions.
    </p>
    <app-code-block [code]="effectsCode" language="typescript" />
    <div class="key-points">
      <h4>Casi d'uso:</h4>
      <ul>
        <li>‚úì Chiamate API</li>
        <li>‚úì WebSocket</li>
        <li>‚úì LocalStorage</li>
        <li>‚úì Routing</li>
      </ul>
    </div>
  </div>

  <div class="concept-card">
    <div class="concept-header">
      <span class="concept-icon">üß©</span>
      <h3>Integrazione Componenti</h3>
    </div>
    <p class="concept-description">
      Come integrare NgRx nei componenti Angular usando l'injection dello Store
      e i selectors.
    </p>
    <app-code-block [code]="componentCode" language="typescript" />
    <div class="key-points">
      <h4>Pattern:</h4>
      <ul>
        <li>‚úì Inject Store</li>
        <li>‚úì Usa selectors</li>
        <li>‚úì Dispatch actions</li>
        <li>‚úì Async pipe</li>
      </ul>
    </div>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê PATTERN GUIDE SECTION (Dynamic) ‚ïê‚ïê‚ïê -->
@if (selectedPattern()) {
  <div id="pattern-guide" class="pattern-guide-section">
    @if (selectedPattern() === 'centralized') {
      <!-- CENTRALIZED STORE GUIDE -->
      <div class="guide-header">
        <h2>üèóÔ∏è Guida Completa: Store Centralizzato (Redux Pattern)</h2>
        <p class="guide-intro">
          Lo <strong>Store Centralizzato</strong> √® il cuore dell'applicazione NgRx seguendo il pattern Redux.
          Tutti i dati dell'applicazione vivono in un unico albero di stato globale, accessibile da qualsiasi
          componente. Questa guida ti accompagner√† passo-passo nella creazione di uno store centralizzato da zero.
        </p>
      </div>

      <!-- STEP 1: State Interface -->
      <div class="guide-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <h3>üìã Definisci le Interfacce di Stato</h3>
          <p class="step-explanation">
            Il primo passo √® creare le interfacce TypeScript che descrivono la forma dei dati.
            Ogni <strong>feature</strong> (funzionalit√†) della tua app avr√† la sua interfaccia di stato.
          </p>
          <div class="example-block">
            <h4>Esempio: Counter State</h4>
            <p>Creiamo uno stato per un semplice contatore con storico:</p>
            <app-code-block [code]="storeCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Cosa stiamo facendo?</strong>
              <ul>
                <li><code>CounterState</code>: definisce la struttura dei dati del counter</li>
                <li><code>count</code>: il valore corrente del contatore</li>
                <li><code>history</code>: array che tiene traccia di tutti i valori passati</li>
                <li><code>initialState</code>: stato iniziale quando l'app parte</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 2: Global State Interface -->
      <div class="guide-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <h3>üåç Crea l'Interfaccia dello Stato Globale</h3>
          <p class="step-explanation">
            Ora combiniamo tutti gli stati delle feature in un'unica interfaccia globale.
            Questo √® il "contenitore principale" che contiene tutto lo stato dell'applicazione.
          </p>
          <div class="example-block">
            <h4>File: store/app.state.ts</h4>
            <app-code-block [code]="centralizedStateCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Perch√© facciamo questo?</strong>
              <ul>
                <li>Ogni feature ha la sua "fetta" nello stato globale</li>
                <li><code>counter</code>, <code>todo</code>, <code>actionsLog</code> sono chiavi dell'oggetto globale</li>
                <li>TypeScript ci d√† autocompletamento e type-safety</li>
                <li>Lo state tree finale sar√†: <code>&#123; counter: &#123;...&#125;, todo: &#123;...&#125;, actionsLog: &#123;...&#125; &#125;</code></li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 3: Actions -->
      <div class="guide-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <h3>‚ö° Definisci le Actions</h3>
          <p class="step-explanation">
            Le <strong>Actions</strong> sono eventi che descrivono "cosa √® successo" nell'app.
            Sono l'unico modo per inviare informazioni allo store. Pensa a loro come "comandi" o "notifiche".
          </p>
          <div class="example-block">
            <h4>File: store/counter/counter.actions.ts</h4>
            <app-code-block [code]="actionsCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Anatomia di un'Action:</strong>
              <ul>
                <li><code>[Counter]</code>: prefisso che identifica la sorgente (buona pratica)</li>
                <li><code>Increment</code>: nome descrittivo dell'azione</li>
                <li><code>props</code>: dati opzionali da passare (es. <code>setValue</code> riceve un valore)</li>
                <li>Le actions sono <strong>immutabili</strong> e <strong>serializzabili</strong></li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 4: Reducers -->
      <div class="guide-step">
        <div class="step-number">4</div>
        <div class="step-content">
          <h3>‚öôÔ∏è Crea i Reducers</h3>
          <p class="step-explanation">
            I <strong>Reducers</strong> sono funzioni pure che prendono lo stato corrente e un'action,
            e ritornano un nuovo stato. NON modificano mai lo stato esistente, ma ne creano una copia aggiornata.
          </p>
          <div class="example-block">
            <h4>File: store/counter/counter.reducer.ts</h4>
            <app-code-block [code]="reducerCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Regole d'oro dei Reducers:</strong>
              <ul>
                <li><strong>Funzioni pure</strong>: stesso input = stesso output, sempre</li>
                <li><strong>Immutabilit√†</strong>: usa spread operator <code>{{ '{' }}...state{{ '}' }}</code> per copiare</li>
                <li><strong>No side effects</strong>: no API calls, no console.log, no modifiche esterne</li>
                <li><code>on()</code>: associa un'action a una funzione che aggiorna lo stato</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 5: Combine Reducers -->
      <div class="guide-step">
        <div class="step-number">5</div>
        <div class="step-content">
          <h3>üîó Combina i Reducers</h3>
          <p class="step-explanation">
            Ora uniamo tutti i reducers delle feature in un unico oggetto usando <code>ActionReducerMap</code>.
            Questo crea la mappa completa di come ogni fetta di stato viene aggiornata.
          </p>
          <div class="example-block">
            <h4>File: store/app.reducers.ts</h4>
            <app-code-block [code]="combinedReducersCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Come funziona?</strong>
              <ul>
                <li>Ogni chiave (<code>counter</code>, <code>todo</code>, ecc.) corrisponde a una feature</li>
                <li>Ogni valore √® il reducer che gestisce quella feature</li>
                <li>NgRx chiamer√† il reducer giusto quando arriva un'action</li>
                <li>Questo √® il "ponte" tra lo stato globale e i reducers individuali</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 6: Provide Store -->
      <div class="guide-step">
        <div class="step-number">6</div>
        <div class="step-content">
          <h3>üöÄ Configura lo Store nell'App</h3>
          <p class="step-explanation">
            Ora dobbiamo "registrare" lo store nell'applicazione Angular usando <code>provideStore()</code>.
            Questo rende lo store disponibile in tutta l'app tramite dependency injection.
          </p>
          <div class="example-block">
            <h4>File: app.config.ts</h4>
            <app-code-block [code]="provideStoreCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Cosa fa questo codice?</strong>
              <ul>
                <li><code>provideStore(appReducers)</code>: inizializza lo store con i reducers combinati</li>
                <li><code>provideStoreDevtools()</code>: attiva le DevTools per debug (solo in dev mode)</li>
                <li><code>maxAge: 25</code>: tiene in memoria le ultime 25 actions per il debug</li>
                <li>Da questo momento lo store √® pronto e accessibile ovunque!</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 7: Selectors -->
      <div class="guide-step">
        <div class="step-number">7</div>
        <div class="step-content">
          <h3>üîç Crea i Selectors</h3>
          <p class="step-explanation">
            I <strong>Selectors</strong> sono funzioni che "estraggono" dati specifici dallo store.
            Sono <strong>memoizzati</strong>, cio√® cachano i risultati per evitare calcoli inutili.
          </p>
          <div class="example-block">
            <h4>File: store/counter/counter.selectors.ts</h4>
            <app-code-block [code]="centralizedSelectorsCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Perch√© usare i Selectors?</strong>
              <ul>
                <li><strong>Memoizzazione</strong>: calcola solo se lo stato cambia, altrimenti usa cache</li>
                <li><strong>Riutilizzabilit√†</strong>: definisci una volta, usa ovunque</li>
                <li><strong>Composizione</strong>: puoi creare selectors complessi da altri selectors</li>
                <li><strong>Type-safety</strong>: TypeScript sa esattamente cosa ritornano</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 8: Component Usage -->
      <div class="guide-step">
        <div class="step-number">8</div>
        <div class="step-content">
          <h3>üß© Usa lo Store nei Componenti</h3>
          <p class="step-explanation">
            Finalmente! Ora possiamo usare lo store nei componenti per leggere lo stato e inviare actions.
          </p>
          <div class="example-block">
            <h4>File: counter.component.ts</h4>
            <app-code-block [code]="componentCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Il ciclo completo:</strong>
              <ol>
                <li>Component <strong>inietta</strong> lo Store nel constructor</li>
                <li>Usa <code>store.select()</code> per <strong>leggere</strong> lo stato (con selector)</li>
                <li>Usa <code>store.dispatch()</code> per <strong>inviare</strong> actions</li>
                <li>Il reducer <strong>aggiorna</strong> lo stato</li>
                <li>Il selector <strong>notifica</strong> il component del cambiamento</li>
                <li>La UI si <strong>aggiorna</strong> automaticamente (grazie all'async pipe!)</li>
              </ol>
            </div>
          </div>
        </div>
      </div>

      <div class="guide-summary">
        <h3>üéâ Congratulazioni!</h3>
        <p>
          Hai appena creato uno <strong>Store Centralizzato</strong> completo con NgRx!
          Ora hai un'unica fonte di verit√† per tutti i dati dell'applicazione, con un flusso
          unidirezionale prevedibile e facilmente debuggabile.
        </p>
        <div class="next-steps">
          <h4>üìö Prossimi passi:</h4>
          <ul>
            <li>Esplora le <strong>Effects</strong> per gestire chiamate API e side effects</li>
            <li>Aggiungi pi√π features seguendo lo stesso pattern</li>
            <li>Usa <strong>Redux DevTools</strong> per vedere lo stato in tempo reale</li>
            <li>Sperimenta con i demo Counter e Todo qui sotto!</li>
          </ul>
        </div>
      </div>
    }

    @if (selectedPattern() === 'feature') {
      <!-- FEATURE STORE GUIDE -->
      <div class="guide-header">
        <h2>‚ö° Guida Completa: Feature Stores (Pattern Modulare)</h2>
        <p class="guide-intro">
          I <strong>Feature Stores</strong> sono store indipendenti registrati dinamicamente per ogni feature.
          Ogni modulo gestisce il proprio stato isolato, ideale per applicazioni modulari, lazy-loading
          o architetture micro-frontend. Questa guida ti mostrer√† come crearli da zero.
        </p>
      </div>

      <!-- STEP 1: Feature State -->
      <div class="guide-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <h3>üìã Definisci lo Stato della Feature</h3>
          <p class="step-explanation">
            Diversamente dallo store centralizzato, ogni feature definisce solo il <strong>proprio</strong> stato,
            senza conoscere lo stato di altre features. Questo garantisce isolamento completo.
          </p>
          <div class="example-block">
            <h4>File: features/counter/store/counter.state.ts</h4>
            <app-code-block [code]="featureStateCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Differenze chiave:</strong>
              <ul>
                <li>Nessuna interfaccia <code>AppState</code> globale</li>
                <li>Ogni feature √® <strong>auto-contenuta</strong></li>
                <li>Lo stato esiste solo quando il modulo √® caricato (lazy-loading)</li>
                <li>Perfetto per features che non condividono mai dati</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 2: Actions & Reducers -->
      <div class="guide-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <h3>‚öôÔ∏è Crea Actions e Reducers (identico allo store centralizzato)</h3>
          <p class="step-explanation">
            Le actions e i reducers funzionano esattamente come nello store centralizzato.
            La differenza sta in <strong>come</strong> vengono registrati nell'app.
          </p>
          <div class="example-block">
            <h4>File: features/counter/store/counter.reducer.ts</h4>
            <app-code-block [code]="featureReducerCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Nota importante:</strong>
              <p>
                Il codice del reducer √® identico al centralizzato. La "magia" avviene nella
                registrazione, che vedremo nel prossimo step!
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 3: Root Store Setup -->
      <div class="guide-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <h3>üåç Setup dello Store Root (Vuoto)</h3>
          <p class="step-explanation">
            Con i Feature Stores, lo store root parte <strong>vuoto</strong>. Ogni feature si registrer√†
            dinamicamente quando viene caricata. Questo permette di caricare solo lo stato necessario.
          </p>
          <div class="example-block">
            <h4>File: app.config.ts</h4>
            <app-code-block [code]="featureProvideCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Perch√© uno store vuoto?</strong>
              <ul>
                <li><code>provideStore(&#123;&#125;)</code>: inizializza lo store senza stato iniziale</li>
                <li>Le features aggiungeranno il loro stato quando necessario</li>
                <li><strong>Bundle size pi√π piccolo</strong> all'avvio</li>
                <li>Perfetto per <strong>lazy-loading</strong>: carica solo ci√≤ che serve</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 4: Feature Registration -->
      <div class="guide-step">
        <div class="step-number">4</div>
        <div class="step-content">
          <h3>üîå Registra la Feature Store (Lazy-Loading)</h3>
          <p class="step-explanation">
            Questo √® il cuore del pattern Feature Store! Quando una route viene caricata,
            registra dinamicamente il suo stato nello store usando <code>provideState()</code>.
          </p>
          <div class="example-block">
            <h4>File: features/counter/counter.routes.ts</h4>
            <app-code-block [code]="featureModuleCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Come funziona?</strong>
              <ul>
                <li>Quando l'utente naviga alla route, Angular carica il modulo</li>
                <li><code>provideState('counter', counterReducer)</code>: registra lo stato nello store</li>
                <li>Lo stato 'counter' appare dinamicamente nello store globale</li>
                <li>Quando l'utente lascia la route, lo stato pu√≤ essere mantenuto o rimosso</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 5: Feature Selectors -->
      <div class="guide-step">
        <div class="step-number">5</div>
        <div class="step-content">
          <h3>üîç Crea i Selectors con createFeatureSelector</h3>
          <p class="step-explanation">
            Per i Feature Stores, usiamo <code>createFeatureSelector</code> invece di selezionare manualmente
            dallo stato globale. NgRx sa trovare automaticamente la feature corretta.
          </p>
          <div class="example-block">
            <h4>File: features/counter/store/counter.selectors.ts</h4>
            <app-code-block [code]="featureSelectorCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Differenze con i selectors centralizzati:</strong>
              <ul>
                <li><code>createFeatureSelector('counter')</code>: seleziona automaticamente la feature</li>
                <li>Non serve definire manualmente <code>(state: AppState) => state.counter</code></li>
                <li>Pi√π conciso e auto-documentante</li>
                <li>Il resto funziona identicamente (memoizzazione, composizione)</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 6: Component Usage -->
      <div class="guide-step">
        <div class="step-number">6</div>
        <div class="step-content">
          <h3>üß© Usa lo Store nei Componenti (identico!)</h3>
          <p class="step-explanation">
            La parte bella? <strong>I componenti non sanno la differenza!</strong>
            Il codice √® identico sia per store centralizzato che feature store.
          </p>
          <div class="example-block">
            <h4>File: features/counter/counter.component.ts</h4>
            <app-code-block [code]="componentCode" language="typescript" />
            <div class="explanation-box">
              <strong>üí° Vantaggi di questa astrazione:</strong>
              <ul>
                <li>Stesso codice nei components per entrambi i pattern</li>
                <li>Puoi <strong>migrare</strong> da feature stores a centralizzato (o viceversa) facilmente</li>
                <li>I componenti sono disaccoppiati dall'architettura dello store</li>
                <li>Testabilit√† identica per entrambi gli approcci</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <div class="guide-summary">
        <h3>üéâ Ottimo lavoro!</h3>
        <p>
          Hai creato un <strong>Feature Store</strong> modulare! Ora la tua app pu√≤ caricare
          dinamicamente lo stato solo quando necessario, perfetto per grandi applicazioni
          con molti moduli indipendenti.
        </p>
        <div class="comparison-box">
          <h4>üìä Store Centralizzato vs Feature Stores</h4>
          <div class="comparison-table">
            <div class="comparison-row header">
              <div>Aspetto</div>
              <div>Centralizzato</div>
              <div>Feature Stores</div>
            </div>
            <div class="comparison-row">
              <div>Setup iniziale</div>
              <div>Tutto definito in app.config</div>
              <div>Root vuoto, features si registrano</div>
            </div>
            <div class="comparison-row">
              <div>Bundle size</div>
              <div>Tutto caricato subito</div>
              <div>Solo ci√≤ che serve (lazy)</div>
            </div>
            <div class="comparison-row">
              <div>Condivisione stato</div>
              <div>Facile tra features</div>
              <div>Pi√π complesso (serve mediazione)</div>
            </div>
            <div class="comparison-row">
              <div>DevTools</div>
              <div>Vista completa sempre</div>
              <div>Vista dinamica (features appaiono/scompaiono)</div>
            </div>
            <div class="comparison-row">
              <div>Ideale per</div>
              <div>App coese e medie dimensioni</div>
              <div>App molto grandi, micro-frontend, plugin</div>
            </div>
          </div>
        </div>
      </div>
    }
  </div>
}

<div class="setup-section">
  <h2>üöÄ Setup & Installazione</h2>
  <div class="setup-grid">
    <div class="setup-step">
      <h3>1. Installazione</h3>
      <app-code-block
        [code]="installCode"
        language="typescript"
      />
      <div class="note-box">
        <strong>‚ö†Ô∏è Nota per Angular 21+:</strong>
        <p>NgRx 20.x richiede Angular 20 come peer dependency. Per Angular 21, usa <code>--legacy-peer-deps</code> o crea un file <code>.npmrc</code> con <code>legacy-peer-deps=true</code></p>
      </div>
    </div>
    <div class="setup-step">
      <h3>2. Configurazione</h3>
      <app-code-block [code]="setupCode" language="typescript" />
    </div>
  </div>
</div>

<div class="best-practices">
  <h2>üí° Best Practices</h2>
  <div class="practices-grid">
    <div class="practice">
      <h4>üìÅ Struttura File</h4>
      <ul>
        <li>Organizza per funzionalit√†</li>
        <li>Mantieni file piccoli</li>
        <li>Usa convenzioni di naming</li>
        <li>Separa le responsabilit√†</li>
        <li>Setup store centralizzato</li>
      </ul>
    </div>
    <div class="practice">
      <h4>üîí Immutabilit√†</h4>
      <ul>
        <li>Usa spread operator</li>
        <li>Non mutare lo stato</li>
        <li>Usa immer se necessario</li>
        <li>Congela lo stato in dev</li>
      </ul>
    </div>
    <div class="practice">
      <h4>üéØ Performance</h4>
      <ul>
        <li>Usa selectors memoizzati</li>
        <li>Normalizza lo stato</li>
        <li>OnPush change detection</li>
        <li>Evita logica nei reducers</li>
      </ul>
    </div>
    <div class="practice">
      <h4>üß™ Testing</h4>
      <ul>
        <li>Testa reducers isolati</li>
        <li>Mock degli effects</li>
        <li>Testa i selectors</li>
        <li>Test di integrazione</li>
      </ul>
    </div>
  </div>
</div>
